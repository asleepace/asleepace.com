<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.7.5"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Scripts --><script type="text/javascript" src="/scripts/htmx.min.js"></script><!-- Canonical URL --><link rel="canonical" href="https://asleepace.com/blog/lowest-common-ancestor/"><!-- Primary Meta Tags --><title>The Lowest Common Ancestor (LCA) Algorithm</title><meta name="title" content="The Lowest Common Ancestor (LCA) Algorithm"><meta name="description" content="An in-depth breakdown of the lowest common ancestor (LCA) algorithm for finding the deepest node in a graph which is a parent of two other nodes."><!-- Theme content --><!-- Yellow Theme --><!-- <meta name="theme-color" content="#f0b000"> --><meta name="theme-color" content="#FFFFFF"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="mobile-web-app-capable" content="yes"><meta name="msapplication-navbutton-color" content="#FFFFFF"><meta name="msapplication-TileColor" content="#FFFFFF"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://asleepace.com/blog/lowest-common-ancestor/"><meta property="og:title" content="The Lowest Common Ancestor (LCA) Algorithm"><meta property="og:description" content="An in-depth breakdown of the lowest common ancestor (LCA) algorithm for finding the deepest node in a graph which is a parent of two other nodes."><meta property="og:image" content="https://asleepace.com/images/abstract-tree.png"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://asleepace.com/blog/lowest-common-ancestor/"><meta property="twitter:title" content="The Lowest Common Ancestor (LCA) Algorithm"><meta property="twitter:description" content="An in-depth breakdown of the lowest common ancestor (LCA) algorithm for finding the deepest node in a graph which is a parent of two other nodes."><meta property="twitter:image" content="https://asleepace.com/images/abstract-tree.png"><!-- Sitemap --><link rel="sitemap" href="/sitemap-index.xml"><link rel="stylesheet" href="/_astro/about.sWteW2aI.css">
<style>footer[data-astro-cid-lejjx2fa]{padding:2em 1em 6em;background:linear-gradient(var(--gray-gradient)) no-repeat;color:rgb(var(--gray));text-align:center}.social-links[data-astro-cid-lejjx2fa]{display:flex;justify-content:center;gap:1em;margin-top:1em}.social-links[data-astro-cid-lejjx2fa] a[data-astro-cid-lejjx2fa]{text-decoration:none;color:rgb(var(--gray))}.social-links[data-astro-cid-lejjx2fa] a[data-astro-cid-lejjx2fa]:hover{color:rgb(var(--gray-dark))}
a[data-astro-cid-xvislcag]{display:inline-block;text-decoration:none}a[data-astro-cid-xvislcag].active{font-weight:bolder;text-decoration:underline}
nav[data-astro-cid-vi7ou4os] a[data-astro-cid-vi7ou4os]{padding:1em .5em;color:var(--black);border-bottom:4px solid transparent;text-decoration:none}nav[data-astro-cid-vi7ou4os] a[data-astro-cid-vi7ou4os].active{text-decoration:none;border-bottom-color:var(--accent)}header[data-astro-cid-vi7ou4os]{margin:0;padding:0;box-shadow:0 2px 8px rgba(var(--black),5%)}
</style></head> <body class="min-h-screen min-w-full items-center self-stretch flex flex-col flex-1 overflow-x-hidden"> <header class="min-w-full" data-astro-cid-vi7ou4os> <nav class="flex flex-row justify-between items-center h-[78px] px-4 bg-white" data-astro-cid-vi7ou4os> <!-- logo and site title --> <div class="basis-1/4 flex flex-row items-center" data-astro-cid-vi7ou4os> <img src="/images/logo.png" width="44" height="44" data-astro-cid-vi7ou4os> <h2 class="hidden xs:block" data-astro-cid-vi7ou4os> <a class="font-black text-lg" href="/" data-astro-cid-vi7ou4os>Asleepace</a> </h2> </div> <!-- navigation buttons --> <div class="flex flex-row gap-x-1 items-center" data-astro-cid-vi7ou4os> <a href="/" data-astro-cid-vi7ou4os="true" data-astro-cid-xvislcag> Home </a>  <a href="/blog" class="active" data-astro-cid-vi7ou4os="true" data-astro-cid-xvislcag> Blog </a>  <a href="/about" data-astro-cid-vi7ou4os="true" data-astro-cid-xvislcag> About </a>  </div> <!-- social media links --> <div class="hidden gap-x-3 sm:flex flex-row basis-1/4 items-center justify-end" data-astro-cid-vi7ou4os> <a href="https://twitter.com/asleepace" target="_blank"> <span class="sr-only">Follow Asleepace on Twitter</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" -><path fill="currentColor" d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z"></path></svg> </a> <a href="https://github.com/asleepace" target="_blank"> <span class="sr-only">Go to Asleepace's GitHub repo</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32"><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg> </a> </div> </nav> </header>  <main class="w-full flex flex-col items-center min-h-screen"> <!-- dynamic content -->  <article class="flex flex-col items-center w-full max-w-screen-md text-gray-800 md:pt-16 pb-8"> <div class="flex flex-1 items-center justify-center w-full"> <img src="/images/abstract-tree.png" alt="The Lowest Common Ancestor (LCA) Algorithm" class="md:rounded-3xl md:shadow-2xl aspect-video md:max-w-screen-md w-full"> </div> <div class="text-center self-stretch px-4 flex flex-col gap-y-2 pt-4 md:pt-8"> <div class="date text-gray-500"> <time datetime="2025-04-20T07:00:00.000Z"> April 20, 2025 </time>  </div> <p class="text-5xl text-balance font-black mb-2">The Lowest Common Ancestor (LCA) Algorithm</p> <hr class="border-b-none border-t-[1px] w-full border-t-gray-200 my-4 mb-8 md:my-8"> </div> <div id="prose" class="flex flex-col gap-y-2 w-full">   <p>The Lowest Common Ancestor or Least Common Ancestor (LCA) algorithm is a classic computer science problem, and one that I’ve had somewhat of a storied personal experience with over my years as a software engineer. Whether you are new to computer science, brushing up for an interview or just a curious individual, I hope you will enjoy this article!</p>
<h3 id="problem-overview">Problem Overview</h3>
<p>First things first, let’s start with a simple definition of the problem, don’t worry if it sounds a bit abstract at first, I promise it is not that bad.</p>
<blockquote>
<p><em>Given a tree or directed acyclic graph and two nodes <code>v</code> &#x26; <code>w</code>, find the deepest node <code>T</code>, such that <code>T</code> is both a parent of <code>v</code> and <code>w</code>.</em></p>
</blockquote>
<p>In more plain terms, given two family members, find the first common ancestor they both share. Given the tree in the image below, the LCA of nodes <code>E</code> &#x26; <code>H</code> would be node <code>B</code>, since node <code>B</code>.</p>
<img src="/images/example-tree-1.png" alt="Example Tree">
<p>A couple things to note as well, each node can have an arbitrary number of children and can be arranged in any sort of particular order. Also a node is considered a direct descendent of itself, so the LCA of node <code>F</code> and <code>H</code> in this example would just be node <code>F</code>.</p>
<h3 id="implementing-the-tree">Implementing the Tree</h3>
<p>Now that we have a basic understanding of the problem, let’s start writing some code! I will be using Typescript for the actual implementation, but it shouldn’t be too hard to follow if you are coming from another programming language as well.</p>
<p>First, let’s define the shape of our node which will be used to recreate the tree above, each node will contain a string value (<code>A</code>, <code>B</code>, <code>C</code>, etc.) and an array of children nodes. I will be writing the node as a class, but this could just as easily be a simple object as well.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#FFAB70"> value</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#FFAB70"> children</span><span style="color:#F97583">:</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8">[] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> []</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">value</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.value </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> value</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Next, let’s add some helper methods for common tree operations, which will be useful for building out our tree. We can start by adding a simple method for retrieving a specific node for a given value:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#B392F0"> find</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">value</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#B392F0"> TreeNode</span><span style="color:#F97583"> |</span><span style="color:#79B8FF"> undefined</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.value </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> value) </span><span style="color:#F97583">return</span><span style="color:#79B8FF"> this</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> child</span><span style="color:#F97583"> of</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.children) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> found</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> child.</span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">(value)</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (found) </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> found</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> undefined</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>The <code>find(value: string)</code> method will return if the current node if the provided value matches the nodes value, otherwise it will recursively check each child node until a match is found. If no match is found, then this method should just return <code>undefined</code>.</p>
<p>Next, let’s write another helper method which will find a node for a given value, and then insert a new child node. This will be quite useful for building the tree.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#B392F0"> insert</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">value</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">parentValue</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> parent</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">(parentValue)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">parent) {</span></span>
<span class="line"><span style="color:#F97583">      throw</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Failed to find node "${</span><span style="color:#E1E4E8">parentValue</span><span style="color:#9ECBFF">}"`</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> child</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8">(value)</span></span>
<span class="line"><span style="color:#E1E4E8">    parent.children.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(child)</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> child</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>The <code>insert(value: string, parentValue: string)</code> method will attempt to find a node in the current tree with the <code>parentValue</code>, and if found, insert a new node with the given <code>value</code> as a child. If the parent node cannot be found, this method will throw an error.</p>
<p>Finally, let’s add one more method which will return the values of our tree as an <strong>in-order</strong> array of strings. To do this we will just create an array containing the current nodes value, then we will add all the values of each child’s subtree recursively.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#B392F0"> getSubtree</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">[] {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> tree</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.value]</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> child</span><span style="color:#F97583"> of</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.children) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> subtree</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> child.</span><span style="color:#B392F0">getSubtree</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#F97583">      for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> childValue</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> subtree) {</span></span>
<span class="line"><span style="color:#E1E4E8">        tree.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(childValue)</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> tree</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Please note that I’ve written the <code>getSubstree()</code> method above in a way which should be understandable for people coming from different languages, but this does come with a slight performance penalty. For this example it shouldn’t matter too much, but as an exercise left for the reader, can you write this method such that we only need to instantiate an array once?</p>
<p>Ok, now that we have finished adding our helper methods, the full <code>TreeNode</code> class should look something like the following:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#FFAB70"> value</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#FFAB70"> children</span><span style="color:#F97583">:</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8">[] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> []</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">value</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.value </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> value</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#B392F0"> find</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">value</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#B392F0"> TreeNode</span><span style="color:#F97583"> |</span><span style="color:#79B8FF"> undefined</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.value </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> value) </span><span style="color:#F97583">return</span><span style="color:#79B8FF"> this</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> child</span><span style="color:#F97583"> of</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.children) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> found</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> child.</span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">(value)</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (found) </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> found</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> undefined</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#B392F0"> insert</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">value</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">parentValue</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> parent</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">(parentValue)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">parent) {</span></span>
<span class="line"><span style="color:#F97583">      throw</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Failed to find node "${</span><span style="color:#E1E4E8">parentValue</span><span style="color:#9ECBFF">}"`</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> child</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8">(value)</span></span>
<span class="line"><span style="color:#E1E4E8">    parent.children.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(child)</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> child</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#B392F0"> getSubtree</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">[] {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> tree</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.value]</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> child</span><span style="color:#F97583"> of</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.children) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> subtree</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> child.</span><span style="color:#B392F0">getSubtree</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#F97583">      for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> subTreeValue</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> subtree) {</span></span>
<span class="line"><span style="color:#E1E4E8">        tree.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(subTreeValue)</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> tree</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Now let’s go ahead and instantiate our tree from the original example, all we need to do is create our root node and call our helper methods:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> root</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'A'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">root.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'B'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'A'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">root.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'C'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'A'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">root.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'D'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'B'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">root.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'E'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'B'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">root.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'F'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'B'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">root.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'G'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'F'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">root.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'H'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'F'</span><span style="color:#E1E4E8">)</span></span></code></pre>
<p>We can verify that our tree has been built correctly by calling the <code>getSubtree()</code> on our root, which should return the following in-order array <code>["A", "B", "D", "E", "F", "G", "H", "C"]</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> output</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> root.</span><span style="color:#B392F0">getSubtree</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(output)</span></span></code></pre>
<p><a href="https://www.typescriptlang.org/play/?target=99#code/MYGwhgzhAEAqBOBTRA5A9gE0dA3gKGmgAcBXAIxAEthoA3MEExALmggBd5KA7AcwOLkqNYAAtKIDEm6sEydFgDaAXWgBeaCrwDgabh3glg7NPAAU9RizacevAJS4BhduIgA6S03V0GTANwCAL7ahKQU1NAAZjwYFn7WBnb2skiomNgAPtAk3Fgx3IgYToSElFHQZq6UHl7Yag2+Vo5I7CTw3NDVEIGl0aaVuvrs0GISxWgV3e5jktKO+H2EQxz9ucUasxjuBXF19r1L5ZVRaOstiG0da3mHhCF9re2d64gFRYchAuHC0DwQiHg7HiVlYST4ABpiGBpOwAGoJMG2PgpOBpBTYRalFYjIgwxDcEYaaa7Mx42EI5p3P4VMwAQnJBPYC2cpVc8DQAHdoIVuQBReAc8wAAwAYmAJEUumhorEeRloAAiAAkOEZhMpTCCiuF9lZD2xelWWx8vLR8gyIKYB1Z6vYM3EcwJ7lIEFEZi2Nsel2eo0dGE+oUEERovEuAGVyJxkGZUeDeCoSobhl00j5FNM6spqad4IMjSMTZMum4HeN5kmlqMC2wo2nNv73GH2JGyNHELHWX1c-mUxByHJEJrsMX+220iyq1X2y6SG6zGPB8O9VPoAb7qyntd24GvgB6PfQABCJHGdhL2HbzG0OOgHLQRJ5iG5g4xZgA5ABBd82+-2-6AsCipHoqUKKp+iq-mgD7uABQJmIqADCoFKhBUEwXBQEACIocBkGBH+sH6IBCF8rhIHof+xHwYqorkfheCEZhCEAOK4XRlFEQCNEABLsQxeC3mc7CkI+hHNq27adisaAgIg7ggGgvBmMJon2EAA">Click here to view on the Typescript Playground!</a></p>
<h3 id="designing-the-algorithm">Designing the Algorithm</h3>
<p>Now that we have a tree we can test, let’s start designing our Lowest Common Ancestor algorithm by first defining the shape of our function. In this example, we will write a function which takes the root node of a tree along with two values, and returns the least common ancestor they share.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> getLCA</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">root</span><span style="color:#F97583">:</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">value1</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">value2</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">  // ...</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>There are several ways to solve this, but we will start will a simple recursive approach. When approaching recursive problems, it is generally a good idea to start by defining our base case.</p>
<p>Since we are looking for a node which is both an ancestor of <code>value1</code> and <code>value2</code>, our base case should just return the current nodes values when these conditions are satisfied. Now how should for this condition?</p>
<p>Remember our <code>find(value: string)</code> helper method above, we can use this check if a child exists at a current node, by checking if it returns a <code>TreeNode</code> or <code>undefined</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> getLCA</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">root</span><span style="color:#F97583">:</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">value1</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">value2</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (root.</span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">(value1) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> root.</span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">(value2)) </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> root.value</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#79B8FF"> undefined</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Once we find a node that is a direct ancestor of both <code>value1</code> and <code>value2</code>, all we need to do is return the current node all the way up the call stack, otherwise we should return <code>undefined</code>. Let’s test our base case with a simple example:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">getLCA</span><span style="color:#E1E4E8">(root, </span><span style="color:#9ECBFF">'B'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'C'</span><span style="color:#E1E4E8">)) </span><span style="color:#6A737D">// outputs "A"</span></span></code></pre>
<p>Awesome, we have now just implemented the logic to check if a node is an ancestor! While this does return an ancestor of two nodes, this is not guaranteed to be the least common ancestor.</p>
<p>To check for the least common ancestor, all we need to do is traverse the tree recursively until we find the last node for which our base condition evaluates to <code>true</code>.</p>
<p>Since the root node of a tree will always be an ancestor of any sub-values in the tree, we should add our traversal logic before our base case. We can do this by first checking if any of the child nodes are the LCA:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> getLCA</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#FFAB70">  root</span><span style="color:#F97583">:</span><span style="color:#B392F0"> TreeNode</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">  value1</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">  value2</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span></span>
<span class="line"><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#F97583"> |</span><span style="color:#79B8FF"> undefined</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  // first check children subtree for LCA</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> child</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> root.children) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> found</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> getLCA</span><span style="color:#E1E4E8">(child, value1, value2)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (found) </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> found</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // the check if current node is the LCA</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (root.</span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">(value1) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> root.</span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">(value2)) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> root.value</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // if current node or subtree does not contain</span></span>
<span class="line"><span style="color:#6A737D">  // the LCA then return undefined</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#79B8FF"> undefined</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Please note I also added a return type to the function, which is just <code>string</code> or <code>undefined</code>. Sweet, now let’s write some test cases and check if our solution works!</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">getLCA</span><span style="color:#E1E4E8">(root, </span><span style="color:#9ECBFF">'B'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'C'</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'A'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">getLCA</span><span style="color:#E1E4E8">(root, </span><span style="color:#9ECBFF">'D'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'F'</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'B'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">getLCA</span><span style="color:#E1E4E8">(root, </span><span style="color:#9ECBFF">'D'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'G'</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'B'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">getLCA</span><span style="color:#E1E4E8">(root, </span><span style="color:#9ECBFF">'F'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'H'</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'F'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">getLCA</span><span style="color:#E1E4E8">(root, </span><span style="color:#9ECBFF">'F'</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">'Z'</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> undefined</span><span style="color:#E1E4E8">) </span><span style="color:#6A737D">// edge case</span></span></code></pre>
<p>If you followed all of the steps above, each of these should output <code>true</code> to the console!</p>
<p><a href="https://www.typescriptlang.org/play/?target=99#code/MYGwhgzhAEAqBOBTRA5A9gE0dA3gKGmgAcBXAIxAEthoA3MEExALmggBd5KA7AcwOLkqNYAAtKIDEm6sEydFgDaAXWgBeaCrwDgabh3glg7NPAAU9RizacevAJS4BhduIgA6S03V0GTANwCAL7ahKQU1NAAZjwYFn7WBnb2skiomNgAPtAk3Fgx3IgYToSElFHQZq6UHl7Yag2+Vo5I7CTw3NDVEIGl0aaVuvrs0GISxWgV3e5jktKO+H2EQxz9ucUasxjuBXF19r1L5ZVRaOstiG0da3mHhCF9re2d64gFRYchAuHC0DwQiHg7HiVlYST4ABpiGBpOwAGoJMG2PgpOBpBTYRalFYjIgwxDcEYaaa7Mx42EI5p3P4VMwAQnJBPYC2cpVc8DQAHdoIVuQBReAc8wAAwAYmAJEUumhorEeRloAAiAAkOEZhMpTCCiuF9lZD2xelWWx8vLR8gyIKYB1Z6vYM3EcwJ7lIEFEZi2Nsel2eo0dGE+oUEERovEuAGVyJxkGZUeDeCoSobhl00j5FNM6spqad4IMjSMTZMum4HeN5kmlqMC2wo2nNv73GH2JGyNHELHWX1c-mUxByHJEJrsMX+220iyq1X2y6SG6zGPB8O9VPoAb7qyntd24GvgB6PfQABCJHGdhL2HbzG0OOgHLQRJ5iG5g4xZgA5ABBd82+-2-6AsCipHoqUKKp+iq-mgD7uABQJmIqADCoFKhBUEwXBQEACIocBkGBH+sH6IBCF8rhIHof+xHwYqorkfheCEZhCEAOK4XRlFEQCNEABLsQxeC3mc7CkI+hHNq27adisaAgIgMxyTC0lGrJ8kgGgvBmMJol6toB7QFhbw8OeZx5gwvCmJQrgALbaFEuTGJQejQM2AAyiGfmYf6pBaWBQnUACMSJcJCTRMAATMFyRRXw0DZK87zFPgrI9h6NZFhUhFbBWWJVrepzrD4bkeR6-r+QkAXlVY4UrlOxxmAVeQXFcnSNQG+pBmUtKEaSgWOAAZP1d7QfavUJDVk5TlunSEXU1JfN6LU5HkRmFO1+6HrAiDGpA203ipcnuOpmnFZ5f5Qu+R7vhdiE-uojRfj+gkHWpGlmKdXkjRdWHXdA76indDQaJdT0yYdx3vZc7lnV9f0-RdLGAw9V16mDr0nVDJXnX9AMXTxSPAwDqMvUdb0fdj-2-e+ABaBPLfkPBFI4+lFGGoy7UAA">Click here to view full example!</a></p>   </div> </article>  </main> <footer class="w-full" data-astro-cid-lejjx2fa>
&copy; 2025 Colin Teahan. All rights reserved.
<div class="social-links" data-astro-cid-lejjx2fa> <a href="https://twitter.com/Asleepace" target="_blank" data-astro-cid-lejjx2fa> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/twitter" data-astro-cid-lejjx2fa><path fill="currentColor" d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z" data-astro-cid-lejjx2fa></path></svg> </a> <a href="https://github.com/Asleepace" target="_blank" data-astro-cid-lejjx2fa> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/github" data-astro-cid-lejjx2fa><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-lejjx2fa></path></svg> </a> </div> <!-- perform some simple analytics tracking --> <script type="module">async function n(){return typeof window>"u"?(console.warn("[trackAnalytics] called from non-browser context, skipping..."),!1):fetch("/api/analytics",{method:"POST",headers:{"user-agent":navigator.userAgent,referer:document.referrer}}).then(e=>e.ok).catch(e=>(console.warn("[trackAnalytics] failed",e),!1))}window.addEventListener("beforeunload",n);</script> </footer>  </body></html>