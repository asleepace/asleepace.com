---
title: 'Typescript Snippets'
description: 'Useful TypeScript snippets for everyday use which can be easily copied and pasted.'
pubDate: 'May 14 2024'
author: 'Colin Teahan'
heroImage: '/images/typescript-banner.png'
hashTags: 'Technical, Snippets, Typescript'
slug: 'typescript-snippets'
---

This document contains a collection of useful, interesting and sometimes quirky snippets of TypeScript I've gathered over the years. Some of these patterns are not unique to TypeScript, but in these examples they should be also type-safe (hopefully).

### SQL Template String w/ Types

```ts
// Extract parameter name between {{ and }}
type ExtractParam<S extends string> = 
  S extends `${infer Param}}${infer _}` ? Param : never

// Recursively find all {{paramName}} patterns
type SQLParamsFromString<S extends string> = 
  S extends `${infer _}{{${infer Rest}`
    ? ExtractParam<Rest> | SQLParamsFromString<Rest>
    : never

function sqlQueryTemplate<SQLString extends string>(statement: SQLString) {
  return {
    prepare(queryParams: Record<SQLParamsFromString<SQLString>, string | number>) {
      let template = statement as string
      let params: string[] = []
      let paramIndex = 0
      
      // Replace {{paramName}} with actual values
      for (const [key, value] of Object.entries(queryParams)) {
        if (value === null || value === undefined || Number.isNaN(value)) continue
        template = template.replace(`{{${key}}}`, String(++paramIndex))
        params.push(String(value))
      }
      
      return {
        template,
        params
      }
    }
  }
}


const userQuery = sqlQueryTemplate('SELECT * FROM past_prompts WHERE user_id = {{userId}}')

const { template, params } = userQuery.prepare({
    userId: 123 // inferred!
})
```

[Try it on the Typescript Playground!](https://www.typescriptlang.org/play/?target=99#code/FAj0oAgUQDwFwE4EMDGcIAcnILYFM48EIA7JfCAIwIHc88SIBvJiJEgEwgF9vg4AnhjzR4yNAAVs5ADwBlCHngMOAZwirEASxIBzAHwQAvBGAQICpYU7qABgBImOgGZEIU3L0cu3AfW62EAD87tI4EABcpHgAbkRgkABKeCgArgiqWnEANgIQzjpcSNnZzExYuABy5Hi8mEhwhAgkqvxCInIAigAyHuSqAGIIAPY4ctp68orKNhoTBsam5pYzahAOTiSuxP4s3ltuyZoBZubBooiocH04MkdwhgA+Fj03gyNj83d4mvqn5lESLF4sBnKkSGgtMNGKoAI7ZTqpIgCAAqeBwGGyDTw8h64wQOl002sa00BL0+gAFJpsfgSHAol1uvjCQBKZinBAEdKMJj-TBcip4SmwpEIARvKLJFDDBAcXG9MLvUYsyZM1UGAA0c3JROeJFSOGoCH07L5ZzO2QIEEIGKxhEWNNtDHQSHUZMJ-PMVvQFX6UQ9egA2gBdRahr0QH31XAASU4SkWAAZI5HwBBkpjUCIWH6cNV8HUaFo4AALNhoVLFCAxYpI1oW8zOWUQSkylroIMAazwAm1teySLDw2cEAA8pQAFYpOAAOhdBJ+IrFEqVrLNkfMWlHlIHSOMRhMBpKEEezz3IkPJnBHDwBSBXDPEEqhuNs60qmqlV3dbw64g7ZwDoSKbja6JZg6Ji2hBeCzoKWIoMKth7EwPYCLwATahqlIANQ4Xm8a3jA66gXmqizhgqSqKWlLYReJGNjwqaMVycA8hyjHmNB9p4JqpFKpGfAWkJTF8CA7aaBAVFEIiyKOvCsnimidrYpSADkchQN0UAAMIohAABUEADIkY4ALL1JovgYB8GBwOoADqAASUCJFAUmqEQvhaFwJgsNJCCxhwvBqay4nQpJrDcdi2pkTwiwBYpAgUYK2DCuaZwBUFUQAIwAEwAMzANwrJAA)


### Builder Pattern

The following snippet creates a typed object by progressively adding properties, this can be useful for defining different errors in an application.

**CAVEAT**: In order for the `this` in `register()` method to work correctly, the definition cannot use an arrow function.

```ts
type ErrorRegistry<T extends string> = Record<T, number> & {
  register<K extends string>(error: K, code: number): ErrorRegistry<K | T>
}

function createErrorRegistry<T extends string>(domain: T) {
  const errorRegistry = {
    register<K extends T>(error: K, code: number) {
      return {
        ...this,
        [error]: code,
      } as ErrorRegistry<T | K>
    },
  } as ErrorRegistry<T>
  return errorRegistry
}

const output = createErrorRegistry('app')
  .register('linking', 100)
  .register('billing', 200)
  .register('surface', 200)
```

[Typescript Playground Link](https://www.typescriptlang.org/play/?target=99#code/C4TwDgpgBAogTnA9nAShA5gSwM7DiAHgBUoIAPYCAOwBNspc5Mr0A+KAXijQGNkbiAGihUArgFsARhDjsAZFADeAKChqocDDkpwCAaVIVqdBnmZsAFDKRwAXFD3C+NCPbFSZASnvwbaLIyEBgA+UESsygC+ysoAZqJUPMCYiFRQPJoAhpS+yP7a+MSGlLT0jOasFjSI4pnM9kSeSqrqfFS4pAh5WoGczeoDGj06+sXG9OFWXXYOTogubhLScE0qg+tDwKJwaWsb+wB0R8AAFjiCLfvrANrWyAC69s4Ql1eRUJn0uajDhSShenYrwG0RBHy+03ygWIEQGmi2O06fl+ICiMTaHUQomAYGxfQyEGyEG+ULwIAsAHJMmAwBTPK8DpoAjpKQAbZgAa3MFOEAEYAAz8+kDRnDGSUySYVnslg8qAAJkFwvUouZ4op2G2sUyPAgcsVQvRqWwiFZEAOrMQ6AsWJx2KaAHoHVAgA)

### Branded Types

The following snippet defines a utility type `Brand<any, string>` which can be used to create an alias of an existing type, which is more strict than the original type.

```ts
declare const BrandSymbol: unique symbol

type Brand<T, Description extends string> = T & {
  [BrandSymbol]: Description
}

// example usage

type UserId = Brand<number, 'UserId'>

function trackUser(userId: UserId) {
  console.log('user:', userId)
}

const userOne = 123 as UserId
const userTwo = 123

trackUser(userOne) // ok
trackUser(userTwo) // error
```

[Typescript Playground Link](https://www.typescriptlang.org/play/?target=99#code/FAEwpgxgNghgTmABBA9gOwM4BdECE4xogDKAngLYBGKUAXIgK5oCWAjg0hhdVMMFqQAOSfIRAAeACoAaRABEwGCHGaCszdIjAAPLGCIZE2FWgDmAPkQBeRJMQAyRAG9giN4gDaoomSo0AuvQKSipqGmjAAL58APQxWtow5IJQSAwYMKZgfALCiACqGGBwAJIg1ngEROJoDFTFsgDkhcVljeZ8AGZMEOqaWAQQANYtcAAU6a0g9KNlAJTOru6omDRgAHRQKKZjjZNwtI2y+-NRfCvYjEVwAPJoSDYAjABMAMyIMIazIMAXOPuSADuKAqL1eOUGI2uE2udzACziiBQQ34kNGMOKQJQCPixTgKDgfCAA)

### Monad\*

The following is a monad-like type which has support for operatings over elements of an array, or the array itself.

```ts
/**
 * This class facilitates the chaining of operations on a value,
 * each task will either return a new Monad or MonadIterable.
 */
export class Monad<I> {
  constructor(public value: I) {}

  public pipe<O>(operation: (value: I) => O[]): MonadIterable<O[]>

  public pipe<O>(operation: (value: I) => O): Monad<O>

  public pipe<O>(operation: (value: I) => O): Monad<O> | MonadIterable<O[]> {
    const result = operation(this.value)
    return Array.isArray(result) ? new MonadIterable(result) : new Monad(result)
  }

  public print(label?: string): Monad<I> {
    console.log(`${label}:` ?? 'value:', this.value)
    return this
  }
}

/**
 * This is an extension of the Monad class that allows for operations
 * on iterable values. The reduce method will convert back to
 * a basic Monad.
 */
export class MonadIterable<I extends any[]> extends Monad<any> {
  public iterate<O>(
    operation: (value: I[number], index?: number, array?: I) => O
  ): MonadIterable<O[]> {
    return new MonadIterable(this.value.map(operation))
  }

  public filter<O>(
    operation: (value: I[number], index?: number, array?: I) => O
  ): MonadIterable<I> {
    return new MonadIterable(this.value.filter(operation))
  }

  public reduce<O>(
    operation: (prev: O, value: I[number], index?: number, array?: I) => O,
    initialValue: Partial<O> = {}
  ): Monad<O> {
    return new Monad(this.value.reduce(operation, initialValue))
  }

  /**
   * Converts an iterable monad back into a normal monad.
   */
  public combine<O>(operation: (value: I) => O): Monad<O> {
    return new Monad(operation(this.value))
  }
}
```

[Try it on the TypeScript playground!](https://www.typescriptlang.org/play/?target=99#code/PQKhCgAIUgVALAlgZ0gYwDYENmoGZZqIaIAuWpApqqfJevFogHYsDmkA9nlwA6UAnCok7NUoyFkgA3LBgCulADRQYlQvEjlkAa0gB3YhkiUydAZAGVS8gc0mRmlfZACyorABMuF98y8AklRCAEYYlAB0qsDgmDiofl4APAEAfJAA3uBQ6KLIpALyaKScAgAUvPJhiGgycooAXJABAJSZAL7ZkJCV1bW8iPxJAPKpZZz8QqQizE1lsgqUTa2QALzpwwDaALotTYmeQYJYYZQjO6ldPVUk-YNno+OTwqJzC43NbeuQw3tuHp4Rpccr1bj17kCnsdpq9IPN6ktPmsNn8DkDIAAff7+Q7BE7hc7bdJZbrdNB5UiWajyDCU1Z8aEzMq0FARd6UFo5bpWGx2SAAQQEQgAnhEUIKRWUrMgaaQ2gB+RzObGBPGnKXU2ltJpOFwHDUyrU5Togm41HoCFikMrYEKUDDypr5S3MNiogEpYlc3JiTjhCIYThsMoAAwAJBlbfb2g0Q5B5YqAOTshqJpRaJDINkIzmkqm8+ws5DG8Am0AQaBwTOQFCSeyUAAeVDEMy4PFo9AO6GwuAzFEkGED+nwpQZUxmxcrEjIx1OdUWWar9CsniK9AAttZ4JxvIZBz7pIJKSFCHoSqoHCfkOaDlFoDE4r2DkdQgSAiYm5RmJ5UFhmMKLg-ZsfxVQE-2FL1TT6Gs8SoSEJkZWF4UWZZNmYeR1ztARtnTFhPEbR1HAwrD0ywIUsGFQiVm+X59gBF98QeQCSVJHlbHsXVQIY9Ui2zRYInXLBeChcdRBaXNIBNbpQXNPBiGCeDnhhWY4RTZo0OIwQcJrb8CJ1TSBFI8jKOWL4UTonFuLfL08zYvlOOfNVwmZTM+MUCI5NpQQRJeZhxJLKCwRXNdIW9BDRJUiorGkJphnTNSAg0zCtNw3SG0I9DksMyRjKosyfhUPMWDIRA5AANQRJoAAUyOmOR0XpDJOm6d0cXRFjuWsdilT1AEXNZdkImCtBKB85TUpK8qcwkqTIHLLkYAAYVEQ8BFIX97BnV8NwBSATzQPQrU4BxmFKQTjHXAE726EAYmks1anJTCWAeMZwt8t5KqRGjWuSUZMm9OyOOVfV3uU-qs3Zfzuk6MtgDWVZEaR5GUdRtH0YxzHwGAeGAFEGywddeHCbH4cx8mKcprHYgpLh5FISo6R60CygyecPgARkkiTugiAZ+DKZkcB0fLtB0Nz6BgAAmAAGGWecgPn7kFzKQny1WIhKABlAp2DKaHSSVgWymdPzkUgU2ImQYmyDKAAiO2Dd5raKFGso0EYAR8o9siIh9gRlvw-lrXlhWPPk7zxmKTh8s4aPNc4HWXWDAAOJ3FeGt3eGi9M0FsL3zYAOQMqLKGkNoAGp0Hz9N5e9PmXWtO28-yTh1wAfSjDBHfr9kgA)

### Define Class via Enum (WIP)

**NOTE**: This has only been tested on TypeScript 5.4.5 and is still expiramental, see [here for example](https://www.typescriptlang.org/play/?target=99&ts=5.5.0-beta#code/MYewdgziA2CmB0w4EMBOAKAlAKF72YArgLYAEAqhLKgMrAAWsxypA3tqZ6YVagJIATUgF5SAcj4A5ACoBRAOKyASqUkB5SavIAZbWIA0HLgDMAlqggAXScmKwR4uQA1pqjVt0GjnaMis27BzFnV3VNSR09QwBfXEsATwAHe1kiYgBhXwgIAB5pAD4Hdi5SMFgAd1J0eBq0AHMIAC5SZDB4gG0AXUxm6WxY7ATk0gB1VFNLWGQAIzg8wtFWUgBaVCmBcGh40naABVJTMFIAa1h4kGNSaU7evc7SaIBuPCGUtN3UEETcgqLvHdO20OJzOFyuN1KJGm1FIAB9SFZxmA6nDSNMQDApkd4QARZCTfq4MC2WAQRLIYD2TJ+CBsf6wAAeiRAqEspGMhDAwEspnApCQNIAYp9iKkSDlZPorvl0AQSHRGMxmrIeqQxRksj9CsUSlw1pZCKgjgLsnTdeb+eBEYRuSz0PUmmr3p9vhL8pg6f8Lbq4Gz6KYBAICDRLPjYMrnV9crIFqQ1NMAFawbnwGmmOpgdCsaJSh04L3ekwsqqgSBsxIu6gJA5HOXEBVMZAe9gFwu60tQODwaAgOroAAGQbMYEOKIrXyr2wAJKxx8lWfFov38222-Gkymh4dYB8Jwv0JZ-RApXPJ1KdavV3XqDM4M1LKhCLBDJfL6WzHVDbfw6QH0+X6+bblOMoazD+f7Pq2gFcHUsBsgAbsg0BPlgZrQZe+qGkc-qBsGoaTO0p4Lp0UHoTmpHQVQCFIShZQMpYABqNGwM2FHoZwOFBmAIZhoRlbEQ4dGMcxbGvrE7FcNEOBkaJ4kWtELS0hehZlJU9qoA0EYkLuroxqqfTenJnCxAMrykAA0mctKiICYKvGClDUA2zDYAA9K5XAAHoAPwvEk9jOcgABChwCKOfwlDw1CCM0aTQqg-xmBY1gks0iKjv8WQpXYaUPhlAwmrSjmoKQjKTGAAi0tS2SIJqwogKKaQ5PZlzFYFUqBSFFWjjKbUMI2rH-FRASwOgHLQNAI25UidSsd6HZsu0SX+CSUpZSN9yiONk0kvAZLQBM6AAESkEd0kWoepgQPAy3ZfYW3mCtdhQZd13rSSDjvc9JQmXg2ALaQxDxMVgkVBQvBZv8UX8AIzQAIwAEwAMwAZwt1TeI6QwIcXglF9P7BFM9CtLjXBlagyD3o+sD9PmQPFXtcEjcdQUgNMpBBTaxyTKgZ24B2mLdr26D07wmBAA).

This allows us to define an enum which will auto-_magically_ be created into a class definition, and then extended. This is great for a simple ORM with SQLite!

```ts
// SPECIAL TYPES

type EnumClass<T> = {
  new (...args: any[]): T
}

type Writeable<T> = { -readonly [P in keyof T]: T[P] }

type EnumProps<T> = {
  [key in keyof T]: number | string | boolean | Date
}

// THE MAGIC

namespace Class {
  export function classFromEnum<E, T>(enumSchema: E): EnumClass<T> {
    return class {
      constructor(args: EnumProps<E>) {
        let hiddenState: EnumProps<E> = Object.assign({}, args)

        for (const property in enumSchema) {
          console.log(`defining property ${property}`)

          Object.defineProperty(this, property, {
            enumerable: true,
            configurable: true,
            writable: true,
            get value() {
              return hiddenState[property]
            },
            set value(nextValue) {
              hiddenState[property] = nextValue
            },
          })
        }
      }
    } as {
      new (args: EnumProps<E>): T
    }
  }
}

// EXAMPLE UASGES

enum UserSchema {
  userId = 'INTEGER NON NULL',
  firstName = 'TEXT NON NULL',
  lastName = 'TEXT NON NULL',
}

type SchemaBinding = {
  userId: number
  firstName: string
  lastName: string
}

class User extends Class.classFromEnum<typeof UserSchema, SchemaBinding>(
  UserSchema
) {
  setName(fullName: string) {
    const [firstName, lastName] = fullName.split(' ')
    this.firstName = firstName
    this.lastName = lastName
  }
}

const myUser = new User({
  userId: 123,
  firstName: 'Bob',
  lastName: 'Smitch',
  extra: true,
})

myUser.setName('Colin Teahan')

console.log(myUser.firstName) // Colin
```

[Try it on the TypeScript Playground](https://www.typescriptlang.org/play/?target=99&ts=5.5.0-beta#code/MYewdgziA2CmB0w4EMBOAKAlAKF72YArgLYAEAqhLKgMrAAWsxypA3tqZ6YVagJIATUgF5SAcj4A5ACoBRAOKyASqUkB5SavIAZbWIA0HLgDMAlqggAXScmKwR4uQA1pqjVt0GjnaMis27BzFnV3VNSR09QwBfXEsATwAHe1kiYgBhXwgIAB5pAD4Hdi5SMFgAd1J0eBq0AHMIAC5SZDB4gG0AXUxm6WxY7ATk0gB1VFNLWGQAIzg8wtFWUgBaVCmBcGh40naABVJTMFIAa1h4kGNSaU7evc7SaIBuPCGUtN3UEETcgqLvHdO20OJzOFyuN1KJGm1FIAB9SFZxmA6nDSNMQDApkd4QARZCTfq4MC2WAQRLIYD2TJ+CBsf6wAAeiRAqEspGMhDAwEspnApCQNIAYp9iKkSDlZPorvl0AQSHRGMxmrIeqQxRksj9CsUSlw1pZCKgjgLsnTdeb+eBEYRuSz0PUmmr3p9vhL8pg6f8Lbq4Gz6KYBAICDRLPjYMrnV9crIFqQ1NMAFawbnwGmmOpgdCsaJSh04L3ekwsqqgSBsxIu6gJA5HOXEBVMZAe9gFwu60tQODwaAgOroAAGQbMYEOKIrXyr2wAJKxx8lWfFov38222-Gkymh4dYB8Jwv0JZ-RApXPJ1KdavV3XqDM4M1LKhCLBDJfL6WzHVDbfw6QH0+X6+bblOMoazD+f7Pq2gFcHUsBsgAbsg0BPlgZrQZe+qGkc-qBsGoaTO0p4Lp0UHoTmpHQVQCFIShZQMpYABqNGwM2FHoZwOFBmAIZhoRlbEQ4dGMcxbGvrE7FcNEOBkaJ4kWtELS0hehZlJU9qoA0EYkLuroxqqfTenJnCxAMrykAA0mctKiICYKvGClDUA2zDYAA9K5XAAHoAPwvEk9jOcgABChwCKOfwlDw1CCM0aTQqg-xmBY1gks0iKjv8WQpXYaUPhlAwmrSjmoKQjKTGAAi0tS2SIJqwogKKaQ5PZlzFYFUqBSFFWjjKbUMI2rH-FRASwOgHLQNAI25UidSsd6HZsu0SX+CSUpZSN9yiONk0kvAZLQBM6AAESkEd0kWoepgQPAy3ZfYW3mCtdhQZd13rSSDjvc9JQmXg2ALaQxDxMVgkVBQvBZv8UX8AIzQAIwAEwAMwAZwt1TeI6QwIcXglF9P7BFM9CtLjXBlagyD3o+sD9PmQPFXtcEjcdQUgNMpBBTaxyTKgZ24B2mLdr26D07wmBAA)

### WebGPU Example

```ts
declare interface Navigator {
    gpu: {
        requestAdapter: () => any
    }
}

async function computeHashesGPU(n: number) {
  if (!navigator.gpu) throw new Error('WebGPU not supported');
  
  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter!.requestDevice();

  // Shader that does the computation
  const shaderCode = `
    @group(0) @binding(0) var<storage, read_write> output: array<f32>;
    
    @compute @workgroup_size(256)
    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      if (idx >= ${n}u) { return; }
      
      // Simulate your hash computation
      var value = f32(idx);
      for (var i = 0u; i < 10u; i = i + 1u) {
        value = sin(value * 2.718281828);
      }
      output[idx] = value;
    }
  `;

  const shaderModule = device.createShaderModule({ code: shaderCode });
  
  // Create buffer for results
  const bufferSize = n * 4; // f32 = 4 bytes
  const buffer = device.createBuffer({
    size: bufferSize,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
  });

  const pipeline = device.createComputePipeline({
    layout: 'auto',
    compute: { module: shaderModule, entryPoint: 'main' }
  });

  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer } }]
  });

  const commandEncoder = device.createCommandEncoder();
  const passEncoder = commandEncoder.beginComputePass();
  passEncoder.setPipeline(pipeline);
  passEncoder.setBindGroup(0, bindGroup);
  passEncoder.dispatchWorkgroups(Math.ceil(n / 256));
  passEncoder.end();
  
  device.queue.submit([commandEncoder.finish()]);
  await device.queue.onSubmittedWorkDone();
}

async function mainGPU() {
  const start = performance.now();
  await Promise.all([
    computeHashesGPU(1_000_000),
    computeHashesGPU(1_000_000),
    computeHashesGPU(1_000_000),
    computeHashesGPU(1_000_000)
  ]);
  console.log('GPU time:', (performance.now() - start) / 1000, 's');
}


mainGPU()
```

[Try it on the Typescript Playground!](https://www.typescriptlang.org/play/?target=99#code/FAgmFMGMBsEMCdwAICWA7ALueAzWlkA5WANxQHNYMB7eJAb2CWaXIAcBXALgaZf8QBHDuADOGAIKhYbLPB4AKAJRIAvAD4ksNAE8+zAL7AjwWKJ1pISHB0sYU1NEkjUAtpywAJMwAsxAcQAFAFUFNB40DlcAI2wVRmYUHCQFAEI0UgoqWgA6dg4VDB94agB3JDRwcoBReBL4BQByAHVwaKDgiuoMJFEONjZaLFBGpQBuPj4XNHEtaVlsNS1S2BQejLJKGng8zhyhEXEpGTllCeZp2YgyAiXYFbW5k+xU-fBhMQwAEXAb8DOQMwAPRApAAZR8sAgdCKVCQoGoYiQRWQLncHAwVAcaCmjlmokh0IAwtQIEsAAb6JAAAXIJX6CgADCpqdF0KB0OQmSoSAgADziWiwcjgAA0SEQUIA+qV4GtwJpqBiPDwEPBYDo+TgAMwAJnU5xYVOpaI8yGppVoAGs6Uq2FLRCgAF7-XUAVgAbEoqTgnK5VmgFKyOChoPZA+RoNRorBoFL0CRqJAsY546AVJHo7G0zwSFBtXyOHr1PEqcxoOAeihQAAPJaZmNx6s5GuG-hJFLVuvqVRIAAk9DQBgKDAllY48DQYyQRn4zDLSBB4JQrg4cCwSB0SrokIJzjcHhTOLnSF5dF50BESx1uoUXfGC5wtBSZ9QS0ZHGnKCQfKQAEYPy-JZvwAan-EcEhPU9YyvXtHUDC8rwAKiQXUcgAdj-AAOXUsOw3CHxPWc5yVDAPAAbS7ABdJZEPANsZz4ckJlxGYegJKFsAAWVJNdkF7a4UAIHJIElLAIU4+AeNAPiFHofcIB4DjiVJZADEIpA+CXIkxOQaIOBwHBFifOhED6MNRFY2Z9MM7AwWdfiKiQFCABZpyXG8lhcpBoh0LBLIuPEehsoy6AE34hPAETdIAIQM0K5KpR0XR4EK7Ic0UqQ4URhXAHgOji2z4GCHKRRyMEABUAHkACUJH8aokAAHyQAr4uwErcpyIkqsCABNKUwRqok+HUljArYpA2BQNhwGgdBHME4TRPAKhwBJdEsECGa5oWxL+DgLcMR4RpYAxahGky-hTQxPLR1cXiKyUwluMesUkHATB4B0QJqHQDATv9dBGkYwwHys4L2X8ek2CWJaopWtaYqhmH9pYQ7SJ4abZvmyo8krZG0FAaG7QAGQ1UjuSulhPowOUxB4cj5LZInOR4RlxTM7cCB4Zn2roAwZyo0bwYm2Y0X9InqksVSwvhCLlt0jbJdAaWXGhAExZ6NgzFENXZaWCXtFVmXoRyWJyHQDazUCXXNam3X9bN0RK22nG9ux3bKg0nXRD103sByF2MEJ4nUY5nyUbtH3HYDnYOVEHWMEgHxmmtW1+lEBQuKoHwRPAUMwkXVDPSUGO-adwPPtAe2+HhnIPhEIOOGiVw1gUcijaluOchwdAUAJZQqI0+5Vh6evG6ixwwRbtuMGGNP4CtL5HH+B8TDMCwrBsOxsSQIG0A6ZReC13pMXgHpe1m3BaEl4S0DKe3R8eQISjbl2cljaAO6pG6vF8AIIQFB-ilIyMBoCwFKGpoFTa4BvAEkAaEEBYDGQQOZNA-csD4F+FEEfZB4CUFQN-geW62DEHALQWg70zBh6GkuNQCsOQoxckaB0ZEK48qXRSNfEyd8ooP1KMfAAtGfBAGAVCggAmA8UjRRCjAmCYYAB8j5KCAA)

### Scope (Tree)

```ts

interface ScopeCtx {
    registry: FinalizationRegistry<string>
}

interface Scope {
    isGlobal: boolean
    label: string
    path: string
    children: WeakRef<Scope>[],
    create(label: string): Scope
    [Symbol.iterator](): IterableIterator<Scope>
    [Symbol.dispose](): void
}

function createGlobalScope() {
    const globalRef = createScope.call({ 
        registry: new FinalizationRegistry<string>((scopePath) => {
            console.log('cleanup called:', scopePath)
        })
    })
    return globalRef
}

function createScope(this: ScopeCtx): Scope {
    let ctx = this
    return {
        label: 'global',
        path: '/',
        children: [],
        get isGlobal() {
            return this.path === '/'
        },
        create(label: string) {
            const child = createScope.call(ctx)
            child.path = this.path + label + '/'
            child.label = label
            const childRef = new WeakRef(child)
            this.children.push(childRef)
            ctx.registry.register(childRef, child.path)
            return child
        },
        *[Symbol.iterator]() {
            yield this
            for (const child of this.children) {
                const childRef = child.deref()
                if (!childRef) continue
                yield* childRef
            }
        },
        [Symbol.dispose]() {
            console.log(`disposed:`, this.label)
        }
    }
}



const globalScope = createGlobalScope()
const scopeA = globalScope.create('a')
const scopeB = globalScope.create('b')
const scopeC = globalScope.create('c')
const scopeD = scopeB.create('d').create('e').create('f')
const scopeG = globalScope.create('g')

{
    using disposedScope = scopeD.create('f_2').globalScope.create('f_3').create('f_4')
}

for (const scope of globalScope) {
    console.log(scope.label)
}

setTimeout(() => {
    console.log('program done')
}, 5_000)
```

[Try it on the Typescript Playground!](https://www.typescriptlang.org/play/?target=99&module=7&ssl=2&ssc=1&pln=77&pc=10&jsx=0#code/MYewdgziA2CmB0w4EMBOAKAlAKGwSzABdZUAzZYWAAgGVQAHWAYUIA8qBvbKnq1WAOZ4IhVAE8AXFQBiBZNDwAvZITzgASoOGixAHhGoCAgHzYAvrgLEyFanRCNO3XsIDi0EACN5UzyBiwyGDOPNDInrDQUgZGIVT0KgAW0aKxvFTAiXjQACb8YFIA6oEA1pqkuvaMxgDaALoANHHA-Cqw6GERUVQxYAKYUlWwcTU0YgC2ftDweNYqIKh1WFIAknOecGsk86iVDLCm6aMTU-A5wvQgELBLA1QAbiB4Oea4pACuYMCq4BmtxO4vPIhlgnOlQJBCFQBB5vNBylQALx-QLEIaIeTQdAcKhxdL8IQGSRUMCwADuMjkCmUPzAmkJOn0qT6xnQ6Ag+wACklMEjjGD0oKeBCoHB4B4BOgAORIQJgd70DKY2A5CRSho9Lk8vG8Mw4dJ6uL8QjvVBgaGw+TlV7YD5fWkotogwhZCCDfYsVh3IYC0KwKHfdjIl3CI3+03mrhC0LhSJSKUwoHQdU6ngJF3xgD0KejGSyuXyUnqTVzAn9VDclqxvKjud4xojVBDEHg6cSSMRyKl2dTVDMJejLVR7U6cZ6zP6vrrIoD+ZySMdaP2GOgWMD+rrwrnraSC+bO5dVAA1FRR9Bj1Ru1Le+Dt2eF2eb7wZ3nsjkEcjSRTisgyrBSOgmRvhum77kBBawGArbvBAiSAXO5QgdObDwAS2jiKhWgiCQ8FvuUGrgTkB6JEhuYNmar65L2-a9gAVMckwwDMcyEAstxTrmYh4JE87Nk+PCkAsVCAeAIiUfOICkE2rqIHO+Q1vxgovoRH7iWcJD-lginpHgUnoAAhCp-68hCqjysMm5ClxPG0eJ1qWX21EDkKDGnOcECXNc7G1puIoBOKICSgABu5nkqhIQUavuZ6kbqcQWBYuDYC+iZwj6yJDm0gJpfsWkvhyDiwAAgguqXAsumXENKyBSjg+X7AAQqVVbopV7RSp4tXJaJUIFYwTDNUmrX-O1wBdfVhUACILn1sANYgI3SjktULcO0qwCtbXSqQ409ZqhWuINOWFatbTSgIXXYD5VAwUYVChVcKrpftjCTadVVSqQAD6ABMK1ldAw1rZ9X0AMybYtIMACxdYlgmoMJE2OJJFpDfsCngqJ-kSuyy4xTa1yEAAKng4ywCA7yEGyvKIvy11+WKONSvQqCBagyDjPd4AbTg-ZUAArF9AAMIuYEAA)

## Streams

```ts

declare const StreamBrand: unique symbol

type Ints = Uint8Array<ArrayBufferLike>
type StreamableStatus = 'init' | 'open' | 'closed'
type StreamId = string & {
    [StreamBrand]: 'v1'
}

function createId() {
    const random = crypto.getRandomValues(new Uint8Array(8))
    const idString = Array.from(random).map((item) => item.toString(36)).join('')
    return idString as StreamId
}

function id(idString: string | StreamId): StreamId {
    return idString as StreamId
}


class ChildStream extends ReadableStream<Ints> {
    public controller?: ReadableStreamDefaultController

    get connected() {
        return Boolean(this.controller)
    }

    constructor(public cleanup: () => void) {
        super({
            start: (controller) => {
                this.controller = controller
            },
            cancel: () => {
                this.controller = undefined
                this.cleanup()
            }
        })
    }

    public enqueue(chunk: Ints) {
        this.controller?.enqueue(chunk)
    }

    public close() {
        this.controller?.close()
    }
}


class Streamable {
    private writable: WritableStream<Ints>
    private children: (ChildStream|null)[] = []
    private writeQueue = Promise.resolve()

    private state = {
        status: 'init' as StreamableStatus
    }

    get status() {
        return this.state.status
    }

    get count() {
        return this.children.length
    }


    constructor(
        public readonly id: StreamId
    ) {
        this.writable = new WritableStream({
            start: () => {
                this.state.status = 'open'
            },
            write: (chunk) => {
                for (const childStream of this.children) {
                    if (!childStream) continue
                    childStream.enqueue(chunk)
                }
            },
            close: () => {
                this.state.status = 'closed'
            }
        })
    }

    public subscribe(): ChildStream {
        const child = new ChildStream(() => {
            const idx = this.children.findIndex((stream) => Object.is(stream, child))
            if (idx !== -1) {
                this.children[idx] = null
            }
        })
        this.children.push(child)
        return child
    }

    public close(): void {
        try {
            if (this.status !== 'open') return console.warn('stream already closed!')
            this.state.status = 'closed'
            this.children.forEach((child) => child?.close())
            this.writable.abort('closed')
        } catch (e) {
            console.warn(e)
        } finally {
            this.children.length = 0
        }
    }

    async transaction(operation: (
        writer: WritableStreamDefaultWriter<Ints>
    ) => Promise<void>) {
        await this.writeQueue
        const writer = this.writable.getWriter()
        try {
            await operation(writer)
        } finally {
            writer.releaseLock()
        }
    }

    async bytes(chunk: Ints) {
        const promise = await this.transaction((writer) => writer.write(chunk))
        this.writeQueue = this.writeQueue.then(() => promise).catch((e) => console.warn(e))
    }
}




class Streams {
    public readonly items = new Map<StreamId, WeakRef<Streamable>>()

    public readonly defer = new FinalizationRegistry((streamIdRef: StreamId) => {
        if (!this.items.has(streamIdRef)) return console.warn('[cleanup] key not found:', streamIdRef)
        const streamRef = this.get(streamIdRef)
        streamRef?.close()
        this.items.delete(streamIdRef)
    })

    get size() {
        return this.items.size
    }

    public has(id: StreamId): boolean;
    public has(stream: Streamable): boolean;
    public has(key: StreamId | Streamable): boolean {
        if (typeof key === 'string') return Boolean(this.get(key))
        if (typeof key === 'object' && 'id' in key) {
            return Boolean(this.get(key.id))
        }
        return false
    }

    public get(streamId: StreamId): Streamable | undefined {
        return this.items.get(streamId)?.deref?.()
    }

    public ref(stream: Streamable): WeakRef<Streamable> {
        const weakRef = new WeakRef(stream)
        this.defer.register(stream, stream.id, weakRef)
        return weakRef
    }

    public add(stream: Streamable): void {
        const streamRef = this.ref(stream)
        this.items.set(stream.id, streamRef)
    }

    public delete(streamId: string | StreamId) {
        return this.items.delete(streamId as StreamId)
    }

    *[Symbol.iterator](): Generator<Streamable> {
        for (const [_id, streamRef] of this.items) {
            const stream = streamRef.deref?.()
            if (!stream) continue
            yield stream
        }
    }
}


function resp(stream: Streamable) {
    return new Response(stream.subscribe(), {
        status: 200,
        headers: {
            'Content-Type': 'text/event-stream'
        } 
    })
}


async function GET(ctx: { url: URL; streams: Streams }): Promise<Response> {
    const id = ctx.url.pathname.slice(1) as StreamId

    // if stream exists, clone and send response
    if (ctx.streams.has(id)) {
        const stream = ctx.streams.get(id)!
        return resp(stream)
    }

    // otherwise, create a new instance
    const stream = new Streamable(id)
    ctx.streams.add(stream)
    return resp(stream)
}
declare const StreamBrand: unique symbol

type Ints = Uint8Array<ArrayBufferLike>
type StreamableStatus = 'init' | 'open' | 'closed'
type StreamId = string & {
    [StreamBrand]: 'v1'
}

function createId() {
    const random = crypto.getRandomValues(new Uint8Array(8))
    const idString = Array.from(random).map((item) => item.toString(36)).join('')
    return idString as StreamId
}

function id(idString: string | StreamId): StreamId {
    return idString as StreamId
}


class ChildStream extends ReadableStream<Ints> {
    public controller?: ReadableStreamDefaultController

    get connected() {
        return Boolean(this.controller)
    }

    constructor(public cleanup: () => void) {
        super({
            start: (controller) => {
                this.controller = controller
            },
            cancel: () => {
                this.controller = undefined
                this.cleanup()
            }
        })
    }

    public enqueue(chunk: Ints) {
        this.controller?.enqueue(chunk)
    }

    public close() {
        this.controller?.close()
    }
}


class Streamable {
    private writable: WritableStream<Ints>
    private children: (ChildStream|null)[] = []
    private writeQueue = Promise.resolve()

    private state = {
        status: 'init' as StreamableStatus
    }

    get status() {
        return this.state.status
    }

    get count() {
        return this.children.length
    }


    constructor(
        public readonly id: StreamId
    ) {
        this.writable = new WritableStream({
            start: () => {
                this.state.status = 'open'
            },
            write: (chunk) => {
                for (const childStream of this.children) {
                    if (!childStream) continue
                    childStream.enqueue(chunk)
                }
            },
            close: () => {
                this.state.status = 'closed'
            }
        })
    }

    public subscribe(): ChildStream {
        const child = new ChildStream(() => {
            const idx = this.children.findIndex((stream) => Object.is(stream, child))
            if (idx !== -1) {
                this.children[idx] = null
            }
        })
        this.children.push(child)
        return child
    }

    public close(): void {
        try {
            if (this.status !== 'open') return console.warn('stream already closed!')
            this.state.status = 'closed'
            this.children.forEach((child) => child?.close())
            this.writable.abort('closed')
        } catch (e) {
            console.warn(e)
        } finally {
            this.children.length = 0
        }
    }

    async transaction(operation: (
        writer: WritableStreamDefaultWriter<Ints>
    ) => Promise<void>) {
        await this.writeQueue
        const writer = this.writable.getWriter()
        try {
            await operation(writer)
        } finally {
            writer.releaseLock()
        }
    }

    async bytes(chunk: Ints) {
        const promise = await this.transaction((writer) => writer.write(chunk))
        this.writeQueue = this.writeQueue.then(() => promise).catch((e) => console.warn(e))
    }
}




class Streams {
    public readonly items = new Map<StreamId, WeakRef<Streamable>>()

    public readonly defer = new FinalizationRegistry((streamIdRef: StreamId) => {
        if (!this.items.has(streamIdRef)) return console.warn('[cleanup] key not found:', streamIdRef)
        const streamRef = this.get(streamIdRef)
        streamRef?.close()
        this.items.delete(streamIdRef)
    })

    get size() {
        return this.items.size
    }

    public has(id: StreamId): boolean;
    public has(stream: Streamable): boolean;
    public has(key: StreamId | Streamable): boolean {
        if (typeof key === 'string') return Boolean(this.get(key))
        if (typeof key === 'object' && 'id' in key) {
            return Boolean(this.get(key.id))
        }
        return false
    }

    public get(streamId: StreamId): Streamable | undefined {
        return this.items.get(streamId)?.deref?.()
    }

    public ref(stream: Streamable): WeakRef<Streamable> {
        const weakRef = new WeakRef(stream)
        this.defer.register(stream, stream.id, weakRef)
        return weakRef
    }

    public add(stream: Streamable): void {
        const streamRef = this.ref(stream)
        this.items.set(stream.id, streamRef)
    }

    public delete(streamId: string | StreamId) {
        return this.items.delete(streamId as StreamId)
    }

    *[Symbol.iterator](): Generator<Streamable> {
        for (const [_id, streamRef] of this.items) {
            const stream = streamRef.deref?.()
            if (!stream) continue
            yield stream
        }
    }
}


function resp(stream: Streamable) {
    return new Response(stream.subscribe(), {
        status: 200,
        headers: {
            'Content-Type': 'text/event-stream'
        } 
    })
}


async function GET(ctx: { url: URL; streams: Streams }): Promise<Response> {
    const id = ctx.url.pathname.slice(1) as StreamId

    // if stream exists, clone and send response
    if (ctx.streams.has(id)) {
        const stream = ctx.streams.get(id)!
        return resp(stream)
    }

    // otherwise, create a new instance
    const stream = new Streamable(id)
    ctx.streams.add(stream)
    return resp(stream)
}
```

[Try it on the TypeScript Playground!](https://www.typescriptlang.org/play/?target=99#code/FAEwpgxgNghgTmABBA9gOwM4BdEGUsIwC2AQnDGiAFyICuaAlgI61IYCeRARilMMFnYAHJAEk0WDIgC8iAKoMJADgCCccuwA8ajSVoAzfWDgAZBgGswAPgHCk+QkRhcoYfDCy0psgOSKGWD6IAD6IPigiaEGhPtAoGGAgPrYieARgxKIgMojYcIoA5ogAZIgA3sCIVYgA2g4ZpOSUALo0PgBuAIzJAL78+vQQWAzoyIRYYFkAFACU5ZXVqJg4TSAoRDkQcMJYKAB0BWBYAEoUa0QAajBQrBhTaGAA7vKKWKrqMOxTSjMzC1VLbCIBggByFHI6T57fRwdZTVbrGZ7JxCKZTAJgIhzaRWYETIh7XZgtAFKYAZgAbL89gArFCKKY+Hx-aqIBCeOBoYGggjgmBSeqZEDAPrAAZoIYjLkg9E8-Ikmh5cGhQVELIzGiqrLzVns2ic7nEor8tKOLIi-jAaD8qQAYQAFgwoHKGogwAAPCaUKTHDIgZyuVWacSSXEVVlCWguBgQZDoAi8VxwAD8NF9MH9Ljc6WIABEwPoYLQoFhbfHYVAk-xWYccEsHkNErMdazqnqDSQULwMmgplhHRg9ksE5XjCzqqLWYCCLQhig4FNI9HY9Ae7QhDRmzjEO16SA5uHW1UMOvjFND0fWdh4FhN8OK0nsWH-pej-2GIP74njJty9+4C+r49AANIBl4QBQEBgFAm5Pi2r5vgOQ5-qOcA5PQ4D6IoiRgQhiDvp+rgUOusy4a2fRAeOVSTtUS5QDGbpoCwYCsFMED2vQ5g0CGGAHmRBHIRID7GMmexgExrCsexnFUYgNFVHRDFxAkzYXq2AlfqhonKWApGsn0opWrAGACjmThZvBiBCPk7QeEgjz5FgAZgDQADqjnOUGPE2BGNl2cgjrOggaCbg6TousQwRoMWUAzDUzQ5PFL7WQwtkTIgDkYgAipJSCyAACrCRAfmAewIBgvDtLpfzJX56XXulshqVeTmeBgbT+IEiAmqqnmtV4L7yYgta5P1dx8a+7ZcgJDWlQ1A36dW1Qjag9BYKpZFTfhSHseFwV7K4JL9oNlpTugeSzrsC5kYpsaEGsaBQOw3KamZ5qshNl4CZlTkWbIDzPO5AR9Y455kS1N6wTIz54YhH57LNCNjTk4SRMksNyaBGM-S5iBsRxaDmHBzWw-o8549OAXhaqiAoPo23w7tQXiZ9GNHgw9NTAAhEzEVYnGEiKKw4Ow7zqpiRJLG6dJhOyRjFGwyBIsAlA8S41uMNs1UM2tXNyO+DpSTK3JZE9LJQ23bkUYYFsDBcNVNBhc6NMkwC511oF2T-U8iBO3zaLE8blMgu6OQaZ7+1YZQ4jgO6aJ5A0cEAPJcDSkBYHsH5TAnxDAVTzq-MbHN4yHiBc9IsgALSdKzbPh3t4k1CHCX-TFxsK0eZv8TtEfiXskYYPa+PhXLbZHPqXK8ydyVRvRK6qypGo7nulmsgQz2u62xd9kh81SOXvgROJzJsuPBqAt2eyPPAvY+DnGzXPdz2G1zzLGzrdlIx4Xgo4b6Ow-XZmaBoTzgAKIwHYmiXmcFebaQXtVUecNBw-WcnsZw851qxHgUkRBclkAeHYnjMAtdXwX1cFfG+UxiGm0QFHa4T1V5fR7g3YBh0Cj9hyAABlNtPVk-J2ASnwk0DAEDhjoCmEfcgYiQp4zIjjOAbkPJZlVPmQsxYsBAwmHAYMEgMA+WqHBQq6wSqaF3CCKwJDqgwGvgEBmyDHJgBylLMilN5FhyQigrMBwjiaLPLg9ejCjzWJgLYyRHgpRTHkbgnotDFD0I3sbeRZVoIZASCYFAEBzB6UvB3E2L5+GCK4OwCYdwZZcUQDxSxbtlhWSKiVHIwTbECQIBQERkpxGRIcXAOCSScb4xkv4jxDinGsHcfDHGIzSr9nEgHaGtTjEJCRBBLAkCqEwPOpfa+nI1nmwtJaIyNpTQNCkGpS2910AMIxEQbwiAAaIAALIwCEJoLUIA86uQyOYX0+gXlmWclYKwpEZ7LlPhmC5z1MI-m9s8AAYnE+iAAvcJ6BfQFA-OveOb0QDfNemafcczN7by5gJK5g57T8mzli75vxT4cknhs8hWzb41FXMRIQCVLDPTQCgHAZMMJUB8Hne+WRqUuPdqNRw3yxmDlrJSvForXz32+XAtW2SkGZ3xIOcArgJhyoaCKgs5sao1iOLkBgCLqqBNpRPOxGrMSDgwOasAvDaKzwYuSu4IJcX6v3DQHg3YKAAG5gVz0QB6vVxBvXEGckvf1RE0DBojG62M4bOVRrVNkFUfysyxq7PGq129BAiDpogTlMgK5hCVCSE+W1OwBt7AJWVnLC6vkLXYEtZaK6H1TunIIxRSh+CSMCLkzarW6jPlyOt8ad7wybWAdgmd9zRM2hO2h1wEguoUsm4aRwI0ZvTeqdNzkQh0EoAWbC2RN5bRJZq7x61hX7lEuABA+hRJqryUmkFL691HpzW5T53zfmOH+Va1xAGCw5DuR8mAXyCx7sGfDSFcBklouwGee+QqzKLrzo8cD+hcFbVwzB75m6rLbozCAH9Rzo1-uXiCUD4qlUQdkAJb998EODlJQjXd99sMSoaAqicS0t0gu1UcXSD7FS8hJCe15VTrUGhvfavYYndUPu6qZPFuyXwACo6icB4FAO1Uj5zNFmDQAA4uJYwHh5xAYaCBzeZM0JsXFTUAA+iCTDkqCwJRLUp658mzo1PvjkJj+gVPGALG+3BrIiXsYFsMaKzqMbsAYNBbI98eGLUMuKdpXJyqonvr+1wtctp3N9BgIQ50JNYZPFwG2+R7azDzpvPeNAABMnDOFY0vPaP0xh2pjuqD4MsEhxJYErgAFTsD4NoExPQAHowBVQkJXe+-9O6IEGn8QyBTYx5ekYgCzoCptsSwO6GgZQ6BwBgvIY4JhA38eIEN1UUgzY0CMcVBImhKvVcwNYSywcvbIAu3sfURmhAeHtGgYgc0566Rrhp6jGbhOIEW4t4E9NQsenRRgPOcQHjdUoLkcS2RCs1ZfNvIY7okaODJRSkENLN6U1C7IGndPjl3tlDMLmK66Wnyq-B0jGPabTLgI8EqBPxhIBgLcn2ihrwShS4sRjZlIM+16lmHnL4Of30HBR4X46BeFeFz0IAA)

## Others...